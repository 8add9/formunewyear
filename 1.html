<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2026 Happy new year</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a1205 0%, #000000 100%);
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            color: #ffd700;
            touch-action: none; /* Prevent default touch actions */
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Loading Screen */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            transition: opacity 1s ease-out;
            cursor: pointer; /* Indicates clickability */
            touch-action: manipulation;
        }

        .loader-text {
            font-size: 24px;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-transform: uppercase;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            pointer-events: none;
        }

        .progress-bar {
            width: 200px;
            height: 2px;
            background: #333;
            position: relative;
            pointer-events: none;
        }

        .progress-fill {
            width: 0%;
            height: 100%;
            background: #ffd700;
            box-shadow: 0 0 10px #ffd700;
            transition: width 0.2s;
        }

        /* Focus Overlay for Images */
        #focus-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 11;
            display: none;
        }

        .close-btn {
            font-size: 30px;
            color: white;
            cursor: pointer;
            text-shadow: 0 0 5px black;
        }
        
        #start-prompt {
            position: absolute;
            bottom: 20%;
            width: 100%;
            text-align: center;
            color: #ffd700;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loader-text">Loading 2026 New Year</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
        <div id="start-prompt">點一下開始</div>
    </div>

    <div id="container"></div>

    <div id="focus-overlay">
        <div class="close-btn" id="btn-close-focus">&times;</div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        import TWEEN from '@tweenjs/tween.js';

        // ==========================================
        // CONFIGURATION
        // ==========================================
        const CONFIG = {
            imageCount: 18, 
            imagePrefix: '', 
            imageSuffix: '.jpg',
            bloomStrength: 0.8, 
            bloomThreshold: 1.0, 
            bloomRadius: 0.3, 
            particleCount: 20000, 
            cakeRadius: 25,
            scatterRadius: 80
        };

        // ==========================================
        // GLOBALS
        // ==========================================
        const container = document.getElementById('container');
        let scene, camera, renderer, composer, controls;
        let font;
        let loadedTextures = [];
        let currentState = 'intro'; // intro, main
        let shapeState = 'cake'; // cake, scatter
        let particleTexture;
        let currentFocusedMesh = null;
        let bgMusic;
        
        // Input state for tap detection
        let startPointer = new THREE.Vector2();
        let isDragging = false;
        let lastTapTime = 0;
        
        // Camera Restore State
        let savedCameraPos = new THREE.Vector3(30, 15, 65); // Default start pos
        let savedControlsTarget = new THREE.Vector3(0, 0, 0);

        // Managers
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let imageMeshes = [];
        let instancedMeshes = []; 
        let cakeBases = []; 
        let introParticles;
        let nebulaParticles;
        let mainGroup = new THREE.Group(); 

        // ==========================================
        // INITIALIZATION
        // ==========================================
        async function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.005); 

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.0; 
            container.appendChild(renderer.domElement);

            // Post Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloomStrength,
                CONFIG.bloomRadius,
                CONFIG.bloomThreshold
            );
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.minDistance = 10;
            controls.maxDistance = 200;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffaa00, 2, 300);
            pointLight.position.set(30, 50, 50);
            scene.add(pointLight);

            const fillLight = new THREE.PointLight(0xffffff, 1.5, 300);
            fillLight.position.set(-30, 20, -30);
            scene.add(fillLight);
            
            // Audio Setup
            bgMusic = new Audio('1.mp3');
            bgMusic.loop = true;
            bgMusic.volume = 0.5;

            // Generate Particle Texture
            particleTexture = createParticleTexture();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            
            // Input Handling
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('dblclick', toggleState);

            // Start Loading
            await loadAssets();
        }

        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.2, 'rgba(255, 240, 150, 0.8)');
            grad.addColorStop(0.5, 'rgba(200, 150, 50, 0.2)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // ==========================================
        // ASSET LOADING
        // ==========================================
        function updateProgress(percent) {
            document.getElementById('progress-fill').style.width = percent + '%';
        }

        async function loadAssets() {
            const manager = new THREE.LoadingManager();
            const textureLoader = new THREE.TextureLoader(manager);
            textureLoader.setCrossOrigin('anonymous'); 
            const fontLoader = new FontLoader(manager);

            manager.onProgress = (url, itemsLoaded, itemsTotal) => {
                updateProgress((itemsLoaded / itemsTotal) * 100);
            };

            const fontPromise = new Promise((resolve, reject) => {
                fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', 
                    (f) => { font = f; resolve(); },
                    undefined,
                    (e) => reject(e)
                );
            });

            const texturePromises = [];
            for (let i = 1; i <= CONFIG.imageCount; i++) {
                const url = `${CONFIG.imagePrefix}${i}${CONFIG.imageSuffix}`; 
                const p = new Promise((resolve) => {
                    textureLoader.load(url, 
                        (tex) => { 
                            tex.colorSpace = THREE.SRGBColorSpace;
                            resolve(tex); 
                        },
                        undefined,
                        () => {
                            // Fallback
                            const canvas = document.createElement('canvas');
                            canvas.width = 512; canvas.height = 512;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = '#111'; 
                            ctx.fillRect(0,0,512,512);
                            ctx.strokeStyle = '#DAA520';
                            ctx.lineWidth = 40;
                            ctx.strokeRect(20,20,472,472);
                            ctx.strokeStyle = '#FFF';
                            ctx.lineWidth = 5;
                            ctx.strokeRect(50,50,412,412);
                            ctx.fillStyle = '#DAA520';
                            ctx.font = 'bold 80px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText("IMG", 256, 200);
                            ctx.font = 'bold 180px Arial';
                            ctx.fillText(i.toString(), 256, 320);
                            const fallbackTex = new THREE.CanvasTexture(canvas);
                            fallbackTex.colorSpace = THREE.SRGBColorSpace;
                            resolve(fallbackTex);
                        }
                    );
                });
                texturePromises.push(p);
            }

            try {
                await fontPromise;
                loadedTextures = await Promise.all(texturePromises);
                
                const startPrompt = document.getElementById('start-prompt');
                startPrompt.style.opacity = 1;
                
                const loadingScreen = document.getElementById('loading-screen');
                
                const startApp = (e) => {
                    // Use pointerup/click to start
                    e.preventDefault();
                    loadingScreen.removeEventListener('pointerup', startApp);
                    
                    // Start Music
                    bgMusic.play().catch(err => console.log('Autoplay blocked:', err));

                    loadingScreen.style.opacity = 0;
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        startIntro();
                    }, 1000);
                };
                
                // Add listener to the specific element, better for mobile
                loadingScreen.addEventListener('pointerup', startApp);

            } catch (error) {
                console.error("Asset load failed", error);
            }
        }

        // ==========================================
        // STAGE 1: INTRO (Particles)
        // ==========================================
        function createTextParticles(text) {
            const isMobile = window.innerWidth < 768;
            let fontSize = 25;
            if (isMobile && text.length > 2) fontSize = 12; 
            else if (isMobile) fontSize = 20; 

            const geometry = new TextGeometry(text, {
                font: font,
                size: fontSize, 
                height: 2, 
                curveSegments: 12, 
                bevelEnabled: true,
                bevelThickness: 1,
                bevelSize: 0.5,
                bevelSegments: 5
            });
            geometry.center();

            const mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial());
            const sampler = new MeshSurfaceSampler(mesh).build();
            
            const count = CONFIG.particleCount;
            const targetPositions = [];
            const tempVec = new THREE.Vector3();

            for(let i=0; i<count; i++) {
                sampler.sample(tempVec);
                targetPositions.push(tempVec.x, tempVec.y, tempVec.z);
            }
            return targetPositions;
        }

        function startIntro() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            
            for(let i=0; i<CONFIG.particleCount; i++) {
                const i3 = i*3;
                positions[i3] = (Math.random() - 0.5) * 300;
                positions[i3+1] = (Math.random() - 0.5) * 200;
                positions[i3+2] = (Math.random() - 0.5) * 200;
                
                const isWhite = Math.random() > 0.7;
                if(isWhite) {
                    colors[i3] = 1.0; colors[i3+1] = 1.0; colors[i3+2] = 1.0;
                } else {
                    colors[i3] = 1.0; colors[i3+1] = 0.85; colors[i3+2] = 0.4;
                }
                sizes[i] = Math.random() * 0.8 + 0.2; 
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                map: particleTexture,
                color: 0xffffff,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true,
                sizeAttenuation: true,
                size: 0.8 
            });

            introParticles = new THREE.Points(geometry, material);
            scene.add(introParticles);

            const sequence = ['5', '4', '3', '2', '1', '2026'];
            let step = 0;

            const runStep = () => {
                if(step >= sequence.length) {
                    transitionToMain();
                    return;
                }

                const text = sequence[step];
                const targets = createTextParticles(text);
                const positions = introParticles.geometry.attributes.position.array;
                const sizes = introParticles.geometry.attributes.size.array;
                
                new TWEEN.Tween({ t: 0 })
                    .to({ t: 1 }, 700)
                    .easing(TWEEN.Easing.Cubic.Out)
                    .onUpdate((obj) => {
                        for(let i = 0; i < CONFIG.particleCount; i++) {
                            const i3 = i * 3;
                            const ti = (i * 3) % targets.length;
                            positions[i3] += (targets[ti] - positions[i3]) * 0.15;
                            positions[i3+1] += (targets[ti+1] - positions[i3+1]) * 0.15;
                            positions[i3+2] += (targets[ti+2] - positions[i3+2]) * 0.15;
                            
                            if(Math.random() > 0.95) {
                                sizes[i] = Math.random() * 1.5 + 0.5;
                            } else {
                                sizes[i] *= 0.95;
                                if(sizes[i] < 0.2) sizes[i] = 0.2;
                            }
                        }
                        introParticles.geometry.attributes.position.needsUpdate = true;
                        introParticles.geometry.attributes.size.needsUpdate = true;
                    })
                    .onComplete(() => {
                         setTimeout(() => {
                             step++;
                             runStep();
                         }, step === sequence.length - 1 ? 1500 : 500); 
                    })
                    .start();
            };
            runStep();
        }

        function transitionToMain() {
            initMainScene();
            const isMobile = window.innerWidth < 768;
            const finalScale = isMobile ? 1.3 : 1.6;

            mainGroup.scale.set(0.01, 0.01, 0.01);
            mainGroup.visible = true;

            new TWEEN.Tween({ scale: 0.01, opacity: 1 })
                .to({ scale: finalScale, opacity: 0 }, 2000)
                .easing(TWEEN.Easing.Exponential.Out)
                .onUpdate((obj) => {
                    introParticles.material.opacity = obj.opacity;
                    mainGroup.scale.set(obj.scale, obj.scale, obj.scale);
                })
                .onComplete(() => {
                    scene.remove(introParticles);
                })
                .start();
            
            new TWEEN.Tween(camera.position)
                .to({ x: 30, y: 15, z: 65 }, 2500)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        }

        function initMainScene() {
            currentState = 'main';
            scene.add(mainGroup);
            createCakeBase();
            createInstancedObjects();
            createImages();
            createMainTitle();
            createDust();
        }

        function createCakeBase() {
            const mat = new THREE.MeshStandardMaterial({ color: 0x4a3c1b, roughness: 0.3, metalness: 0.8 });
            const defs = [{ r: 16, h: 7, y: -6 }, { r: 12, h: 7, y: 1 }, { r: 8, h: 7, y: 8 }];
            defs.forEach(def => {
                const geo = new THREE.CylinderGeometry(def.r * 0.9, def.r, def.h, 64);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(0, def.y, 0);
                mainGroup.add(mesh);
                cakeBases.push(mesh);
            });
        }

        function getScatterPosition() {
            const vec = new THREE.Vector3();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 40 + Math.random() * CONFIG.scatterRadius;
            vec.x = r * Math.sin(phi) * Math.cos(theta);
            vec.y = r * Math.sin(phi) * Math.sin(theta);
            vec.z = r * Math.cos(phi);
            return vec;
        }

        function createInstancedObjects() {
            const geoSphere = new THREE.SphereGeometry(0.25, 16, 16);
            // Significantly increased emissive intensity to surpass the high bloom threshold (1.0)
            const matChampagne = new THREE.MeshStandardMaterial({ color: 0xffeebb, emissive: 0xffcc88, emissiveIntensity: 3.0, roughness: 0.2, metalness: 0.8 });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 3.0, roughness: 0.1, metalness: 0.5 });
            const matRuby = new THREE.MeshStandardMaterial({ color: 0x880000, emissive: 0x550000, emissiveIntensity: 4.0, roughness: 0.1, metalness: 0.7 });
            const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 3.5, roughness: 0.1, metalness: 1.0 });

            const meshDefs = [
                { geo: geoSphere, mat: matChampagne, count: 1200 },
                { geo: geoSphere, mat: matWhite, count: 800 },
                { geo: geoSphere, mat: matRuby, count: 400 },
                { geo: geoSphere, mat: matGold, count: 800 }
            ];

            const dummy = new THREE.Object3D();

            meshDefs.forEach((def, typeIdx) => {
                const mesh = new THREE.InstancedMesh(def.geo, def.mat, def.count);
                const cakePositions = [];
                const scatterPositions = [];
                
                for(let i=0; i<def.count; i++) {
                    const sPos = getScatterPosition();
                    scatterPositions.push(sPos.x, sPos.y, sPos.z);
                    const tier = i % 3;
                    const tierYCenter = (tier * 7) - 6; 
                    const tierRBase = 16 - (tier * 4); 
                    const angle = Math.random() * Math.PI * 2;
                    const hVar = (Math.random() - 0.5) * 6.5; 
                    const cy = tierYCenter + hVar;
                    const r = tierRBase + 0.1 + Math.random() * 0.8; 
                    const cx = Math.cos(angle) * r;
                    const cz = Math.sin(angle) * r;

                    cakePositions.push(cx, cy, cz);
                    dummy.position.set(cx, cy, cz);
                    const scale = 0.8 + Math.random() * 0.8;
                    dummy.scale.setScalar(scale);
                    dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
                mainGroup.add(mesh);
                instancedMeshes.push({ mesh: mesh, count: def.count, cakeData: cakePositions, scatterData: scatterPositions, currentData: [...cakePositions] });
            });
        }

        function createImages() {
            const planeGeo = new THREE.PlaneGeometry(5, 3.75);
            const frameGeo = new THREE.BoxGeometry(5.2, 3.95, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.1, metalness: 1.0 });

            loadedTextures.forEach((tex, i) => {
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

                // Reverted to MeshBasicMaterial to ensure photos are fully bright and unaffected by lighting
                const mat = new THREE.MeshBasicMaterial({ 
                    map: tex, 
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(planeGeo, mat);
                
                const frame = new THREE.Mesh(frameGeo, frameMat);
                frame.position.z = -0.1;
                mesh.add(frame);

                mesh.userData = { 
                    id: i, 
                    isImage: true,
                    originalPos: new THREE.Vector3(),
                    originalRot: new THREE.Euler()
                };

                const angle = (i / CONFIG.imageCount) * Math.PI * 2;
                const radius = 30; 
                const y = (i / CONFIG.imageCount) * 24 - 10; 
                
                mesh.position.set(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
                mesh.lookAt(0, y, 0); 
                
                mesh.userData.cakePos = mesh.position.clone();
                mesh.userData.cakeRot = mesh.rotation.clone();
                
                const sPos = getScatterPosition();
                // Push images further out (1.5x) so they are easier to find
                sPos.multiplyScalar(1.5);
                
                mesh.userData.scatterPos = sPos;
                mesh.userData.scatterRot = new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0);

                mainGroup.add(mesh);
                imageMeshes.push(mesh);
            });
        }

        function createMainTitle() {
            const width = 2048;
            const height = 512;
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 20; 
            ctx.fillStyle = '#fff6cc'; 
            ctx.font = 'bold 160px "Microsoft YaHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("2026 新年快樂", width/2, height/2);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;

            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(40, 10, 1);
            sprite.position.set(0, 24, 0); 
            mainGroup.add(sprite);
        }

        function createDust() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const sizes = [];
            for(let i=0; i<1500; i++) {
                pos.push((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*200);
                sizes.push(Math.random() * 1.5);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const mat = new THREE.PointsMaterial({ 
                map: particleTexture,
                color: 0xffd700, 
                size: 1.0, 
                transparent: true, 
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            nebulaParticles = new THREE.Points(geo, mat);
            scene.add(nebulaParticles);
        }

        function toggleState(e) {
            if(currentState !== 'main') return;
            shapeState = shapeState === 'cake' ? 'scatter' : 'cake';
            
            const isMobile = window.innerWidth < 768;
            const maxScale = isMobile ? 1.3 : 1.6;
            const targetBaseScale = shapeState === 'cake' ? 1 : 0.01;
            const baseEasing = shapeState === 'cake' ? TWEEN.Easing.Back.Out : TWEEN.Easing.Back.In;
            
            cakeBases.forEach(mesh => {
                new TWEEN.Tween(mesh.scale)
                    .to({ x: targetBaseScale, y: targetBaseScale, z: targetBaseScale }, 1000)
                    .easing(baseEasing)
                    .start();
            });

            const targetImageScale = shapeState === 'cake' ? 1.0 : 6.0;

            imageMeshes.forEach(mesh => {
                const targetPos = shapeState === 'cake' ? mesh.userData.cakePos : mesh.userData.scatterPos;
                const targetRot = shapeState === 'cake' ? mesh.userData.cakeRot : mesh.userData.scatterRot;

                new TWEEN.Tween(mesh.position).to({ x:targetPos.x, y:targetPos.y, z:targetPos.z }, 1500)
                    .easing(TWEEN.Easing.Cubic.InOut).start();
                new TWEEN.Tween(mesh.rotation).to({ x:targetRot.x, y:targetRot.y, z:targetRot.z }, 1500)
                    .easing(TWEEN.Easing.Cubic.InOut).start();
                // Scale Tween: 1.0 for Cake, 6.0 for Scatter
                new TWEEN.Tween(mesh.scale).to({ x: targetImageScale, y: targetImageScale, z: targetImageScale }, 1500)
                    .easing(TWEEN.Easing.Cubic.InOut).start();
            });

            const targetT = shapeState === 'cake' ? 0 : 1; 
            new TWEEN.Tween({ t: shapeState === 'cake' ? 1 : 0 })
                .to({ t: targetT }, 2000)
                .easing(TWEEN.Easing.Elastic.Out)
                .onUpdate((obj) => {
                    updateInstancedPositions(obj.t);
                })
                .start();
        }

        function updateInstancedPositions(t) {
            const dummy = new THREE.Object3D();
            instancedMeshes.forEach(data => {
                const { mesh, count, cakeData, scatterData } = data;
                for(let i=0; i<count; i++) {
                    const i3 = i*3;
                    const cx = cakeData[i3]; const cy = cakeData[i3+1]; const cz = cakeData[i3+2];
                    const sx = scatterData[i3]; const sy = scatterData[i3+1]; const sz = scatterData[i3+2];

                    dummy.position.set(cx + (sx - cx) * t, cy + (sy - cy) * t, cz + (sz - cz) * t);
                    dummy.rotation.set(t*Math.PI*2, t*Math.PI, 0);
                    dummy.scale.setScalar(1.0 - t * 0.4); 
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;
            });
        }

        // ==========================================
        // INPUT HANDLING
        // ==========================================
        function onPointerDown(event) {
            isDragging = false;
            startPointer.x = event.clientX;
            startPointer.y = event.clientY;
        }

        function onPointerUp(event) {
            const dx = event.clientX - startPointer.x;
            const dy = event.clientY - startPointer.y;
            // Treat as tap if movement is small (< 5px)
            if (Math.abs(dx) < 5 && Math.abs(dy) < 5) {
                const currentTime = Date.now();
                if (currentTime - lastTapTime < 300) {
                    // Double Tap Detected
                    toggleState(event);
                    lastTapTime = 0; // Prevent immediate re-trigger
                } else {
                    // Single Tap
                    lastTapTime = currentTime;
                    onTap(event);
                }
            }
        }

        function onTap(event) {
            if(currentState !== 'main') return;

            // Recalculate pointer based on exact tap location
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            // Recursive must be true to hit frames/children
            const intersects = raycaster.intersectObjects(imageMeshes, true);

            if (intersects.length > 0) {
                // Traverse up to find the actual image mesh
                let target = intersects[0].object;
                while(target.parent && target.parent !== mainGroup && !target.userData.isImage) {
                    target = target.parent;
                }
                
                if (target.userData.isImage) {
                    focusImage(target);
                }
            } else {
                if(controls.enabled === false) { 
                    resetView();
                }
            }
        }

        function focusImage(mesh) {
            if(controls.enabled) {
                // Save state before disabling controls and moving
                savedCameraPos.copy(camera.position);
                savedControlsTarget.copy(controls.target);
            }
            
            controls.enabled = false;
            currentFocusedMesh = mesh;
            document.getElementById('focus-overlay').style.display = 'block';

            new TWEEN.Tween(mesh.scale)
                .to({ x: 2.0, y: 2.0, z: 2.0 }, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

            const worldPos = new THREE.Vector3();
            mesh.getWorldPosition(worldPos);
            
            const offset = new THREE.Vector3(0, 0, 12);
            const worldRot = new THREE.Quaternion();
            mesh.getWorldQuaternion(worldRot);
            offset.applyQuaternion(worldRot);
            
            const targetPos = worldPos.clone().add(offset);

            new TWEEN.Tween(camera.position)
                .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
                
            new TWEEN.Tween(controls.target)
                .to({ x: worldPos.x, y: worldPos.y, z: worldPos.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
        }

        function resetView() {
            document.getElementById('focus-overlay').style.display = 'none';
            controls.enabled = true;
            
            // Determine scale to return to based on current shape state
            const targetScale = shapeState === 'cake' ? 1.0 : 6.0;

            if(currentFocusedMesh) {
                new TWEEN.Tween(currentFocusedMesh.scale)
                .to({ x: targetScale, y: targetScale, z: targetScale }, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
                currentFocusedMesh = null;
            }

            // Restore Camera Position
            new TWEEN.Tween(camera.position)
                .to({ x: savedCameraPos.x, y: savedCameraPos.y, z: savedCameraPos.z }, 1000)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();

            // Restore Controls Target
            new TWEEN.Tween(controls.target)
                .to({ x: savedControlsTarget.x, y: savedControlsTarget.y, z: savedControlsTarget.z }, 1000)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        document.getElementById('btn-close-focus').addEventListener('click', resetView);

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            TWEEN.update();
            controls.update();

            if(currentState === 'main') {
                if(nebulaParticles) nebulaParticles.rotation.y = time * 0.03;
                if(controls.enabled) {
                    mainGroup.rotation.y += 0.0005;
                }
                if(shapeState === 'scatter') {
                    imageMeshes.forEach((mesh, i) => {
                         mesh.position.y += Math.sin(time + i) * 0.02;
                    });
                }
            }
            composer.render();
        }

        init().then(() => {
            animate();
        });

    </script>
</body>
</html>
